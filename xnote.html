<!-- Card HTML -->
<div id="card-container" data-draw-mode="text">
    <div id="char-info">-</div>

    <div id="hanzi-lines">
        <div class="hanzi">‎ </div>
        <div id="hanzi-line1" class="hanzi">{{text-sc}}</div>
    </div>

    <div class="container-A">
        <div class="content-wrapper center-square">
            <!-- Hub: width equals the square; rail is a sidecar that doesn't affect centering -->
            <div class="draw-hub">
                <div id="draw-slot" class="draw-slot" data-mode="draw">
                    <div class="draw-square">
                        <svg xmlns="http://www.w3.org/2000/svg" class="grid-color" id="hanzi-draw" viewBox="0 0 100 100"
                            preserveAspectRatio="none">
                            <g id="char-grid">
                                <line x1="0" y1="0" x2="100" y2="100" />
                                <line x1="100" y1="0" x2="0" y2="100" />
                                <line x1="50" y1="0" x2="50" y2="100" />
                                <line x1="0" y1="50" x2="100" y2="50" />
                                <line x1="0" y1="0" x2="100" y2="0" />
                                <line x1="0" y1="100" x2="100" y2="100" />
                                <line x1="0" y1="0" x2="0" y2="100" />
                                <line x1="100" y1="0" x2="100" y2="100" />
                            </g>
                        </svg>
                    </div>

                    <!-- Replacement text layer (initially hidden in draw mode) -->
                    <div class="draw-text" aria-hidden="false">
                        <span id="draw-text-content" class="draw-text-inner hanzi">{{text-sc}}</span>
                    </div>
                </div>

                <!-- Side rail: absolutely positioned so it doesn't shift the square -->
                <div class="button-container rail" aria-label="Grid actions">
                    <button id="sound-toggle" class="flat-btn" aria-label="Settings">声</button>
                    <button id="change-mode" class="flat-btn" aria-label="Settings">设</button>
                    <button id="draw-toggle" class="flat-btn" aria-label="Settings">X</button>
                    <button id="tatoeba-lookup" class="flat-btn" aria-label="Example sentence">句</button>
                    <button id="pleco-lookup" class="flat-btn" aria-label="Lookup in Pleco">鱼</button>
                </div>
            </div>
        </div>
    </div>


    <div id="similar-quiz">-</div>

    <div id="buttons">
        <button id="run-animation" class="flat-btn" aria-label="Write animation">写</button>
        <button id="toggle-outline" class="flat-btn" aria-label="Toggle outline">描</button>
        <button id="next-character" class="flat-btn" aria-label="Next character">换</button>
        <button id="restart-quiz" class="flat-btn" aria-label="New quiz">新</button>
        <button id="play-full-audio" class="flat-btn" aria-label="Play audio">声</button>
    </div>

    <div id="pinyin-quiz">
        <div id="quiz-buttons">
            <button class="tone-btn flat-btn" data-tone="1" aria-label="Tone 1"></button>
            <button class="tone-btn flat-btn" data-tone="2" aria-label="Tone 2"></button>
            <button class="tone-btn flat-btn" data-tone="3" aria-label="Tone 3"></button>
            <button class="tone-btn flat-btn" data-tone="4" aria-label="Tone 4"></button>
            <button class="tone-btn flat-btn" data-tone="5" aria-label="Neutral tone"></button>
        </div>
    </div>

    <div id="debug-log">
        <ul id="log-messages"></ul>
    </div>
</div>

<!-- <script src="https://unpkg.com/hanzi-writer"></script> -->
<script src="_xiezh_hanzi-writer.min.js"></script>
<script>
    var xversion = "4.1"
    var xlog = (message) => {
        const logContainer = document.getElementById("log-messages");
        logContainer.hidden = false;
        const logEntry = document.createElement("li");
        logEntry.textContent = message;
        logContainer.appendChild(logEntry);
    }
    var errCheck = (f) => {
        return (...args) => {
            try { f(...args) } catch (e) {
                xlog("errCheck: " + e);
                xlog(e.stack);
                throw e;
            }
        }
        return f;
    }
    var xperfTimestamp = 0
    var xperf = (message, reset) => {
        let stamp = performance.now()
        if (reset) {
            xperfTimestamp = stamp
        }
        xlog("perf: " + message + ": " + ((stamp - xperfTimestamp) | 0) + "ms")
    }

    (() => {
        xlog("<script> v" + xversion + " loaded=" + !!globalThis.xnoteLoaded);
        window.onerror = (message, source, lineno, colno, error) => {
            xlog("window.onerror: " + message + " " + source + " " + lineno + " " + colno + " " + error);
        }
        globalThis.xnoteLoaded = true;
    })();

    var assetPrefix = (globalThis.ankiPlatform == "desktop" ? ""
        : globalThis.AnkiDroidJS ? "https://appassets.androidplatform.net"
            : ".") + "/";

    var loadAssetJSON = (name) => fetch(assetPrefix + name, { cache: "force-cache" })
        .then((r) => {
            let res = r.json();
            xperf("asset " + name)
            return res
        });

    var xcacheGet = (prop) => {
        if (typeof prop != "string") {
            throw new Error("bad xcache parameters");
        }
        return sessionStorage.getItem("_xiehz_" + prop) ?? undefined
    }
    var xcacheSet = (prop, v) => {
        if (typeof prop != "string" || typeof v != "string") {
            throw new Error("bad xcache parameters");
        }
        sessionStorage.setItem("_xiehz_" + prop, v)
        return v;
    }

    var setupClickerBtn = (btnName, onClick) => {
        document.getElementById(btnName).addEventListener('click', errCheck(onClick));
    };

    var buildSpans = (div, arr, cb) => {
        div.innerHTML = ''
        arr.forEach((elem, idx) => {
            const span = document.createElement('span');
            span.textContent = elem
            cb(span, idx)
            div.appendChild(span);
        });
    };

    /**********************************************************************/
    // configs

    var xconfig = undefined;

    var xnoteConfigs = (() => {
        const writeTrue = {
            similarQuizResetTime: 300,
        }
        const writeHard = {
            outline: true,
            outlineTime: 1000,
            similarQuizResetTime: 300,
        }
        const writeEasy = {
            outline: true,
            similarQuizResetTime: 300,
        }
        const noWriting = {
            visible: true,
        }
        const configs = [writeTrue, writeHard, writeEasy, noWriting]
        configs.forEach((conf, idx) => conf.idx = idx)

        let configIdx = Number(xcacheGet("configIdx") ?? xcacheSet("configIdx", "0"));
        xconfig = configs[configIdx];

        return {
            next: () => {
                configIdx = (configIdx + 1) % configs.length;
                xcacheSet("configIdx", configIdx.toString())
                xconfig = configs[configIdx];
                xlog("set global config: " + configIdx)
            }
        }
    })();

    /**********************************************************************/
    // styling

    var xstyle = (prop) => {
        return getComputedStyle(document.documentElement).getPropertyValue('--' + prop).trim()
    }

    var fadeto = (cf, ct, sc) => {
        const s2n = (s) => parseInt(s.substr(1), 16);
        const nf = s2n(cf)
        const nt = s2n(ct)
        let res = 0;
        for (let i = 0; i < 3; ++i) {
            let m = 0xff << (i * 8)
            res += ((nt & m) * sc + (nf & m) * (1 - sc)) & m
        }
        return "#" + res.toString(16).padStart(6, "0")
    }

    var setRandomHanziFont = () => {
        const HANZI_FONTS = [
            'xcard-fzshusong', 'xcard-fzfangsong', 'xcard-fzkaiti', 'xcard-fzxingkai',
            'xcard-chenjixingshu', 'xcard-sentypea',
            'xcard-mbanquetpprc',
            // 'xcard-like',
            '?'];
        const f = HANZI_FONTS[Math.floor(Math.random() * HANZI_FONTS.length)];
        document.getElementById('card-container')?.style.setProperty('--hanzi-font', `'${f}'`);
        xlog("font: " + f)
    }

    /**********************************************************************/
    // hanzi processing

    var hanziData = (() => {
        const data = {}
        const loader = async (data) => {
            const freqlist = await loadAssetJSON("_xiezh_freqs.json");
            function sortMapKeysByStringOrder(map, orderStr) {
                const order = Object.fromEntries([...orderStr].map((k, i) => [k, i]));
                return new Map([...map].sort(([a], [b]) => (order[a] ?? Infinity) - (order[b] ?? Infinity)));
            }

            let hgraph = await loadAssetJSON("_xiezh_decomp_light.json").then((dataString) => {
                let hgraph = new Map()
                let start = 0;
                let end;

                while ((end = dataString.indexOf(';', start)) !== -1) {
                    let oldstart = start // clumsy code to make it faster
                    start = end + 1
                    let line = dataString.slice(oldstart, end).trim()
                    const [char, decomposition] = line.split(':');
                    const [typeOfDecomposition, partsStr] = decomposition.split(/[()]/);
                    hgraph.set(char, {
                        sym: char,
                        type: typeOfDecomposition.trim(),
                        parts: partsStr.split(','),
                        usedin: []
                    });
                }
                return hgraph
            })

            // hgraph = sortMapKeysByStringOrder(hgraph, freqlist)

            for (const node of hgraph.values()) {
                node.parts = node.parts.map(sym => hgraph.get(sym)).filter((sym) => sym != undefined)
            }

            for (const node of hgraph.values()) {
                for (let part of node.parts) {
                    part.usedin.push(node)
                }
            }
            xperf("hanzidata initialized")

            data.freqlist = freqlist
            data.hgraph = hgraph
            return data
        };

        let fetchPromise = undefined;
        data.fetch = async () => {
            if (!fetchPromise) {
                fetchPromise = loader(data)
            }
            return fetchPromise
        }

        return data
    })()

    var HanziChar = class {
        constructor(sym, py) {
            this.sym = sym
            this.py = py;
            {
                let pydata = HanziChar.decodePinyin(py)
                this.pyBase = pydata.base
                this.pyTone = pydata.tone
            }
            this.audio = new Audio(`_xiezh_p_${this.pyBase + this.pyTone}.mp3`);
        }

        toString = () => {
            return `HanziChar{${this.sym}/${this.py}}`
        }

        static buildChars = (hText, hPinyin) => {
            let characters = hText.split("");
            let pinyins = hPinyin.replace("//", "").split(" ");
            if (characters.length == 0 || characters.length != pinyins.length) {
                xlog("broken input: " + hText + " " + hPinyin)
                return [new HanziChar("误", "wù")];
            }
            return characters.map((_, i) => new HanziChar(characters[i], pinyins[i]))
        }

        static decodePinyin = (pinyin) => {
            const toneMap = { '\u0304': 1, '\u0301': 2, '\u030C': 3, '\u0300': 4 };
            let tone = 5;
            let base = '';

            for (const char of pinyin.normalize('NFD')) {
                if (toneMap[char]) {
                    tone = toneMap[char];
                } else if (!char.match(/\p{M}/u)) {
                    base += char; // exclude diacritics
                }
            }
            return { base, tone };
        }
    };

    /**********************************************************************/
    // hanzi writer

    var hanziWriter = (() => {
        let hanzi = undefined;
        let onComplete = undefined;
        let isOutlineVisible = false;
        const writer = HanziWriter.create('hanzi-draw', '', {
            width: 100, height: 100, padding: 0,
            strokeColor: xstyle('stroke-color'),
            drawingColor: xstyle('stroke-color'),
            outlineColor: xstyle('outline-color'),
            highlightCompleteColor: xstyle('char-background'),
            drawingWidth: 24,
            strokeFadeDuration: 150,
            strokeAnimationSpeed: 1.7, delayBetweenStrokes: 50,
            charDataLoader: (char, onComplete, onError) => {
                char == "" ? undefined
                    : loadAssetJSON(`_xiezh_w_${char}.json`).then(onComplete).catch(onError)
            },
            onLoadCharDataError: (e) => xlog("Writer char data load failed: " + e),
            showCharacter: false,
            showOutline: isOutlineVisible,
        })
        const setOutline = (v) => {
            (isOutlineVisible = v) ? writer.showOutline() : writer.hideOutline()
        }
        const setupHanzi = () => {
            writer.setCharacter(hanzi.sym);
            const pycolor = xstyle('py-color' + hanzi.pyTone);
            writer.updateColor('strokeColor', pycolor);
            writer.updateColor('drawingColor', pycolor);
            writer.updateColor('highlightCompleteColor', fadeto(pycolor, xstyle('stroke-color'), 0.3));
        }
        const handleMistake = (strokeData) => {
            xlog("mistake: " + !isOutlineVisible + strokeData.mistakesOnStroke)
            if (!isOutlineVisible) return;
            if (strokeData.mistakesOnStroke < 0) return; // TODO: configure

            writer.animateStroke(strokeData.strokeNum, { onComplete: resetQuiz })
        }
        const resetQuiz = () => {
            setOutline(xconfig.outline);
            writer.quiz({
                showHintAfterMisses: 2,
                markStrokeCorrectAfterMisses: 3,
                leniency: 1.3,
                onComplete: () => { onComplete?.() },
                onMistake: handleMistake,
            })
            if (xconfig.outlineTime) {
                setTimeout(() => setOutline(false), xconfig.outlineTime)
            }
        };

        setupClickerBtn('toggle-outline', () => setOutline(!isOutlineVisible));
        setupClickerBtn('run-animation', () => writer.animateCharacter());

        return {
            reset: (hanzi_, onComplete_) => {
                xlog("writer reset: " + hanzi_);
                hanzi = hanzi_;
                onComplete = onComplete_;
                writer.hideCharacter(); // prevent blinking
                setupHanzi();
                xconfig.visible ? writer.showCharacter() : resetQuiz();
            },
            forceCompletion: () => {
                xlog("writer forceCompletion: " + hanzi);
                writer.cancelQuiz();
                writer.showCharacter();
            },
            resetQuiz: resetQuiz
        }
    })();

    /**********************************************************************/
    // char display

    var charDisplay = (() => {
        return {
            reset: (hanziArr_, completedIdx_) => {
                for (let div of [document.getElementById("hanzi-line1"), document.getElementById("draw-text-content")]) {
                    buildSpans(div, hanziArr_.map(hanzi => hanzi.sym), (span, idx) => {
                        span.style.color = completedIdx_[idx]
                            ? xstyle('py-color' + hanziArr_[idx].pyTone)
                            : xstyle('stroke-color')
                    })
                }
            }
        }
    })();

    /**********************************************************************/
    // similar characters quiz

    var similarQuiz = (() => {
        let onSuccess;
        let hanzi;

        const rsort = (arr) => arr.sort(() => Math.random() - 0.5)
        const getSymArr = async (sym) => {
            let node = (await hanziData.fetch()).hgraph.get(sym)
            if (node == undefined) {
                return ""
            }

            const fn = (node, num) => {
                return node.parts.map(part => {
                    let res = part.usedin.slice(0, num).map(n => n.sym).filter(s => s != sym)
                    return res.length != 0 ? res : fn(part, num / 2)
                }).flat()
            };

            let similar = fn(node, 6)
            similar.push(...node.usedin.map(n => n.sym).slice(4))

            similar = similar.filter((sym) => sym.length == 1)
            similar = rsort(similar).slice(0, 9)
            similar.push(sym)
            return rsort(similar)
        }

        const div = document.getElementById("similar-quiz");
        const setupDiv = (text) => {
            buildSpans(div, text, (span, idx) => {
                span.classList.add('ch')
            })
        };

        div.addEventListener('click', (e) => {
            const el = e.target.closest('.ch');
            if (!el) { return }
            let correct = el.textContent == hanzi.sym
            el.style.textDecoration = correct ? 'underline' : 'overline'
            if (correct) {
                el.style.color = xstyle('py-color' + hanzi.pyTone)
                onSuccess?.()
                if (xconfig.similarQuizResetTime) {
                    setTimeout(() => similarQuiz.resetQuiz(), xconfig.similarQuizResetTime);
                }
            }
        });

        const resetQuiz = () => getSymArr(hanzi.sym).then(text => setupDiv(text, hanzi));

        return {
            reset: (hanzi_, onSuccess_) => {
                onSuccess = onSuccess_
                hanzi = hanzi_
                resetQuiz()
            },
            resetQuiz: resetQuiz,
        }
    })();

    /**********************************************************************/
    // pinyin quiz

    var pinyinQuiz = (() => {
        let hanzi = undefined;
        let onSuccess = undefined;

        const forEachBtn = (cb) => {
            document.querySelectorAll('.tone-btn').forEach((btn, index) => cb(btn, index + 1))
        }

        const flushButtonColors = () => {
            forEachBtn((btn, pyTone) => {
                // btn.style.backgroundColor = '';
                btn.style.backgroundColor = xstyle('py-color' + pyTone)
                btn.onmouseover = btn.onmouseout = null
            });
        };

        forEachBtn((btn, pyTone) => {
            btn.addEventListener('click', errCheck(() => {
                flushButtonColors();
                if (pyTone === hanzi.pyTone || pyTone === 5) {
                    onSuccess?.()
                }
            }));
        });

        return {
            reset: (hanzi_, onSuccess_) => {
                xlog("pinyinQuiz reset: " + hanzi_)
                hanzi = hanzi_
                onSuccess = onSuccess_
                flushButtonColors();
            }
        }
    })();

    /**********************************************************************/
    // main

    var xnote = (() => {
        let hanziArr = undefined;
        let completedIdx = undefined;
        let charIdx = 0;

        const activeHanzi = () => {
            return hanziArr[charIdx]
        }

        const activeHanziCompleted = () => {
            return completedIdx[charIdx]
        }

        const nextChar = () => {
            if (hanziArr.length > 1) {
                charIdx = (charIdx + 1) % hanziArr.length;
                update();
            }
        }

        const displayPinyin = () => { // TODO: refactor
            document.getElementById("char-info").innerText += " / " + activeHanzi().py
        }

        const onCharCompleted = () => {
            if (!activeHanziCompleted()) {
                displayPinyin()
            }
            completedIdx[charIdx] = true;
            charDisplay.reset(hanziArr, completedIdx);
            if (xcacheGet("soundOn") == "on") {
                activeHanzi().audio.play();
            }
        }

        const updateCharInfo = (data, hanzi) => {
            let elem = document.getElementById("char-info");
            let node = data.hgraph.get(hanzi.sym)
            if (node == undefined) {
                elem.innerText = "no data"
                return
            }
            let fidx = data.freqlist.indexOf(hanzi.sym)
            let parts = node.parts.map(n => n.sym).join("")
            let usedin = node.usedin.slice(0, 7)
                .map(n => n.sym).filter(s => {
                    let idx = data.freqlist.indexOf(s);
                    return idx != -1 && idx < 4000 // TODO: configure
                })
                .join("")
            elem.innerText = "" + (fidx == -1 ? "" : fidx)
                + " " + hanzi.sym + " / " + parts + " / " + usedin;
            if (activeHanziCompleted()) {
                displayPinyin()
            }
        }

        const update = () => {
            const hanzi = activeHanzi();
            xlog("xnote updateChar: " + charIdx + hanzi);
            hanziWriter.reset(hanzi, () => {
                onCharCompleted();
            });
            if (activeHanziCompleted()) {
                hanziWriter.forceCompletion()
            }
            pinyinQuiz.reset(hanzi, () => {
                onCharCompleted();
                hanziWriter.forceCompletion();
            });
            similarQuiz.reset(hanzi, () => {
                onCharCompleted();
                hanziWriter.forceCompletion();
            });
            hanziData.fetch().then(data => updateCharInfo(data, hanzi))
        }

        setRandomHanziFont()

        setupClickerBtn('next-character', () => nextChar());

        setupClickerBtn('restart-quiz', () => {
            hanziWriter.resetQuiz();
            similarQuiz.resetQuiz();
        })

        setupClickerBtn('play-full-audio', () => {
            let idx = 0;
            const playNext = () => {
                if (idx < hanziArr.length) {
                    const audio = hanziArr[idx++].audio;
                    audio.play();
                    audio.onended = () => {
                        audio.onended = undefined;
                        playNext();
                    }
                }
            }
            playNext();
        });

        setupClickerBtn('pleco-lookup', () => {
            const text = hanziArr.map(h => h.sym).join("")
            window.open(`plecoapi://x-callback-url/s?q=${text}`, '_blank');
        });

        setupClickerBtn('tatoeba-lookup', () => {
            const text = hanziArr.map(h => h.sym).join("")
            const url =
                `https://tatoeba.org/en/sentences/search?from=cmn&has_audio=&list=&native=&original=
                &orphans=no&query=${encodeURIComponent(text)}&sort=relevance&sort_reverse=&tags=
                &to=eng&trans_filter=limit&trans_has_audio=&trans_link=&trans_orphan=
                &trans_to=eng&trans_unapproved=&trans_user=&unapproved=no&user=&word_count_max=&word_count_min=10`
                    .replace(/\s+/g, '');
            window.open(url, "blank_");
        });

        setupClickerBtn('change-mode', () => {
            xnoteConfigs.next()
            document.getElementById("change-mode").innerText = xconfig.idx.toString()
            completedIdx = {}
            update()
        });

        const setDrawMode = (mode /* 'draw' | 'text' */) => {
            xcacheSet("drawMode", mode)
            const slot = document.getElementById('draw-slot');
            slot.dataset.mode = mode;
            // Optional: keep accessibility in sync
            slot.querySelector('.draw-text')?.setAttribute('aria-hidden', mode === 'draw' ? 'true' : 'false');
            const root = document.getElementById('card-container');
            root?.setAttribute('data-draw-mode', mode);

            document.getElementById('hanzi-lines').setAttribute('aria-hidden', mode === 'text' ? 'true' : 'false');
        }

        setDrawMode(xcacheGet("drawMode") ?? xcacheSet("drawMode", "text"))

        setupClickerBtn('draw-toggle', () => {
            const slot = document.getElementById('draw-slot');
            setDrawMode(slot?.dataset.mode === 'text' ? 'draw' : 'text');
        });

        xcacheGet("soundOn") ?? xcacheSet("soundOn", "on")

        setupClickerBtn('sound-toggle', () => {
            xcacheSet("soundOn", xcacheGet("soundOn") == "on" ? "off" : "on")
        });

        // Run once on load (or whenever you change card content)
        document.addEventListener('DOMContentLoaded', setRandomHanziFont);

        return {
            reset: (hText, hPinyin) => {
                xlog("xnote init: " + hText + " " + hPinyin)
                hanziArr = HanziChar.buildChars(hText, hPinyin)
                completedIdx = {}
                document.getElementById('next-character').style.visibility =
                    hanziArr.length > 1 ? 'initial' : 'hidden';
                update();
            }
        }
    })();

    (async () => {
        xperf("main routine start", true)
        hanziData.fetch()
        errCheck(() => xnote.reset("{{text-sc}}", "{{pinyin}}"))()
        xperf("main routine finish")
    })()

</script>