<div id="card-container" style="padding: 0px; font-family: Arial, sans-serif; transition: all 0.3s;"></div>

<div id="char-info" style="font-size: 18px; padding: 3px; line-height: 1;">-</div>

<div id="hanzi-lines" style="text-align: center; padding: 0px;">
    <div style="font-size: 56px; line-height: 1; font-family: 'xcard-xingkai';">{{text-sc}}</div>
    <div style="font-size: 70px; line-height: 1; font-family: 'xcard-likeandkaiti';">{{text-sc}}</div>
</div>

<div class="container-A" style="margin: 0 auto; position: relative; width: fit-content;">
    <div class="content-wrapper" style="display: flex; align-items: center; justify-content: center;">
        <div style="text-align:center; padding: 3px; display: flex; align-items: center; justify-content: center;">
            <svg xmlns='http://www.w3.org/2000/svg' width='100%' height='100%' class='grid-color' id='hanzi-draw'>
                <g id="char-grid">
                    <line x1='0' y1='0' x2='100%' y2='100%' stroke='var(--btn-background)' />
                    <line x1='100%' y1='0' x2='0' y2='100%' stroke='var(--btn-background)' />
                    <line x1='50%' y1='0' x2='50%' y2='100%' stroke='var(--btn-background)' />
                    <line x1='0' y1='50%' x2='100%' y2='50%' stroke='var(--btn-background)' />
                    <line x1='0' y1='0' x2='100%' y2='0' stroke='var(--btn-background)' />
                    <line x1='0' y1='100%' x2='100%' y2='100%' stroke='var(--btn-background)' />
                    <line x1='0' y1='0' x2='0' y2='100%' stroke='var(--btn-background)' />
                    <line x1='100%' y1='0' x2='100%' y2='100%' stroke='var(--btn-background)' />
                </g>
            </svg>
        </div>
        <div class="button-container"
            style="display: flex; flex-direction: column; position: absolute; left: 100%; padding: 5px;">
            <button id="pleco-lookup" class="flat-btn">鱼</button>
            <button id="tatoeba-lookup" class="flat-btn">t</button>
            <button id="change-mode" class="flat-btn">设</button>
        </div>
    </div>
</div>

<div id="buttons" style="display: flex; justify-content: space-around; padding: 5px; font-size: 24px;">
    <button id="run-animation" class="flat-btn">写</button>
    <button id="toggle-outline" class="flat-btn">描</button>
    <button id="next-character" class="flat-btn">换</button>
    <button id="play-full-audio" class="flat-btn">声</button>
    <button id="restart-quiz" class="flat-btn">新</button>
</div>

<div id="pinyin-quiz" style="padding: 5px; text-align: center;">
    <div id="quiz-buttons" style="display: flex; justify-content: center; gap: 12px;">
        <button class="tone-btn flat-btn" data-tone="1"></button>
        <button class="tone-btn flat-btn" data-tone="2"></button>
        <button class="tone-btn flat-btn" data-tone="3"></button>
        <button class="tone-btn flat-btn" data-tone="4"></button>
        <button class="tone-btn flat-btn" data-tone="5"></button>
    </div>
</div>

<div id="similar-quiz"
    style="text-align: center; padding: 5px; font-size: 32px; line-height: 1; font-family: 'xcard-kaiti'">-</div>
<style>
    #similar-quiz {
        white-space: pre-wrap;
    }

    #similar-quiz .ch {
        display: inline-block;
        cursor: pointer;
        user-select: none;
    }
</style>

<div id="debug-log"
    style="margin-top: 100px; padding: 10px; background: #f9f9f9; border: 1px solid #ddd; font-size: 12px; color: #333; max-height: 100px; overflow-y: auto;">
    <ul id="log-messages" style="list-style-type: none; padding: 0;"></ul>
</div>
</div>

<!-- <script src="https://unpkg.com/hanzi-writer"></script> -->
<script src="_xiezh_hanzi-writer.min.js"></script>
<script>
    var xversion = "4.1"
    var xlog = (message) => {
        const logContainer = document.getElementById("log-messages");
        logContainer.hidden = false;
        const logEntry = document.createElement("li");
        logEntry.textContent = message;
        logContainer.appendChild(logEntry);
    }
    var errCheck = (f) => {
        return (...args) => {
            try { f(...args) } catch (e) {
                xlog("errCheck: " + e);
                xlog(e.stack);
                throw e;
            }
        }
        return f;
    }

    (() => {
        xlog("<script> v" + xversion + " loaded=" + !!globalThis.xnoteLoaded);
        window.onerror = (message, source, lineno, colno, error) => {
            xlog("window.onerror: " + message + " " + source + " " + lineno + " " + colno + " " + error);
        }
        globalThis.xnoteLoaded = true;
    })();

    var assetPrefix = (globalThis.ankiPlatform == "desktop" ? ""
        : globalThis.AnkiDroidJS ? "https://appassets.androidplatform.net"
            : ".") + "/";

    var loadAssetJSON = (name) => fetch(assetPrefix + name, { cache: "force-cache" }).then((r) => r.json());

    var xcacheGet = (prop) => {
        if (typeof prop != "string") {
            throw new Error("bad xcache parameters");
        }
        return sessionStorage.getItem("_xiehz_" + prop) ?? undefined
    }
    var xcacheSet = (prop, v) => {
        if (typeof prop != "string" || typeof v != "string") {
            throw new Error("bad xcache parameters");
        }
        sessionStorage.setItem("_xiehz_" + prop, v)
        return v;
    }

    var setupClickerBtn = (btnName, onClick) => {
        document.getElementById(btnName).addEventListener('click', errCheck(onClick));
    };

    var buildSpans = (div, arr, cb) => {
        div.innerHTML = ''
        arr.forEach((elem, idx) => {
            const span = document.createElement('span');
            span.textContent = elem
            cb(span, idx)
            div.appendChild(span);
        });
    };

    /**********************************************************************/
    // configs

    var xconfig = undefined;

    var xnoteConfigs = (() => {
        const writeTrue = {
        }
        const writeHard = {
            outline: true,
            outlineTime: 1000,
        }
        const writeEasy = {
            outline: true,
        }
        const noWriting = {
            visible: true,
        }
        const configs = [writeTrue, writeHard, writeEasy, noWriting]

        let configIdx = Number(xcacheGet("configIdx") ?? xcacheSet("configIdx", "0"));
        xconfig = configs[configIdx];

        return {
            next: () => {
                configIdx = (configIdx + 1) % configs.length;
                xcacheSet("configIdx", configIdx.toString())
                xconfig = configs[configIdx];
                xlog("set global config: " + configIdx)
            }
        }
    })();

    /**********************************************************************/
    // styling

    ((theme) => {
        const themeStyles = {
            dark: {
                'char-background': '#000000',
                'stroke-color': '#ffffff',
                'outline-color': '#444444',
                'py-color1': '#ff8080',
                'py-color2': '#80ff80',
                'py-color3': '#8080ff',
                'py-color4': '#df80ff',
                'py-color5': '#c6c6c6',
                'btn-background': '#222222',
                'btn-color': '#ffffff',
                'btn-hover': '#333333',
            },
            light: {
                'char-background': '#ffffff',
                'stroke-color': '#000000',
                'outline-color': '#aaaaaa',
                'py-color1': '#e30000',
                'py-color2': '#02b31c',
                'py-color3': '#1510f0',
                'py-color4': '#8900bf',
                'py-color5': '#777777',
                'btn-background': '#f5f5f5',
                'btn-color': '#000000',
                'btn-hover': '#dddddd'
            }
        };
        const commonThemeStyle = {
            'true-color': '#00cc00',
            'false-color': '#cc0000',
        }
        const n2prop = (n) => "--" + n;
        const addStyles = (s) => Object.keys(s).forEach(key => {
            document.documentElement.style.setProperty(n2prop(key), s[key]);
        });
        addStyles(commonThemeStyle);
        addStyles(themeStyles[theme]);
    })(window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light');

    var xstyle = (prop) => {
        return getComputedStyle(document.documentElement).getPropertyValue('--' + prop).trim()
    }

    var fadeto = (cf, ct, sc) => {
        const s2n = (s) => parseInt(s.substr(1), 16);
        const nf = s2n(cf)
        const nt = s2n(ct)
        let res = 0;
        for (let i = 0; i < 3; ++i) {
            let m = 0xff << (i * 8)
            res += ((nt & m) * sc + (nf & m) * (1 - sc)) & m
        }
        return "#" + res.toString(16).padStart(6, "0")
    }

    /**********************************************************************/
    // hanzi processing

    var hanziData = (() => {
        const data = {}
        data.fetch = async () => {
            if (data.freqlist != undefined) {
                return data
            }
            const freqlist = await loadAssetJSON("_xiezh_freqs.json");
            function sortMapKeysByStringOrder(map, orderStr) {
                const order = Object.fromEntries([...orderStr].map((k, i) => [k, i]));
                return new Map([...map].sort(([a], [b]) => (order[a] ?? Infinity) - (order[b] ?? Infinity)));
            }

            let hgraph = await loadAssetJSON("_xiezh_decomp.json").then((dataString) => {
                let hgraph = new Map()
                let start = 0;
                let end;

                while ((end = dataString.indexOf(';', start)) !== -1) {
                    let oldstart = start // clumsy code to make it faster
                    start = end + 1
                    if (dataString.indexOf(":", oldstart) != oldstart + 1) {
                        continue;
                    }
                    let line = dataString.slice(oldstart, end).trim()
                    const [char, decomposition] = line.split(':');
                    const [typeOfDecomposition, partsStr] = decomposition.split(/[()]/);
                    hgraph.set(char, {
                        sym: char,
                        type: typeOfDecomposition.trim(),
                        parts: partsStr.split(',').filter((sym) => sym.length <= 1),
                        usedin: []
                    });
                }
                return hgraph
            })

            hgraph = sortMapKeysByStringOrder(hgraph, freqlist)

            for (const node of hgraph.values()) {
                node.parts = node.parts.map(sym => hgraph.get(sym)).filter((sym) => sym != undefined)
            }

            for (const node of hgraph.values()) {
                for (let part of node.parts) {
                    part.usedin.push(node)
                }
            }

            data.freqlist = freqlist
            data.hgraph = hgraph
            return data
        };

        return data
    })()

    var HanziChar = class {
        constructor(sym, py) {
            this.sym = sym
            this.py = py;
            {
                let pydata = HanziChar.decodePinyin(py)
                this.pyBase = pydata.base
                this.pyTone = pydata.tone
            }
            this.audio = new Audio(`_xiezh_p_${this.pyBase + this.pyTone}.mp3`);
        }

        toString = () => {
            return `HanziChar{${this.sym}/${this.py}}`
        }

        static buildChars = (hText, hPinyin) => {
            let characters = hText.split("");
            let pinyins = hPinyin.replace("//", "").split(" ");
            if (characters.length == 0 || characters.length != pinyins.length) {
                xlog("broken input: " + hText + " " + hPinyin)
                return [new HanziChar("误", "wù")];
            }
            return characters.map((_, i) => new HanziChar(characters[i], pinyins[i]))
        }

        static decodePinyin = (pinyin) => {
            const toneMap = { '\u0304': 1, '\u0301': 2, '\u030C': 3, '\u0300': 4 };
            let tone = 5;
            let base = '';

            for (const char of pinyin.normalize('NFD')) {
                if (toneMap[char]) {
                    tone = toneMap[char];
                } else if (!char.match(/\p{M}/u)) {
                    base += char; // exclude diacritics
                }
            }
            return { base, tone };
        }
    };

    /**********************************************************************/
    // hanzi writer

    var hanziWriter = (() => {
        let hanzi = undefined;
        let onComplete = undefined;
        let isOutlineVisible = false;
        const writer = HanziWriter.create('hanzi-draw', '', {
            width: 210, height: 210, padding: 5,
            strokeColor: xstyle('stroke-color'),
            drawingColor: xstyle('stroke-color'),
            outlineColor: xstyle('outline-color'),
            highlightCompleteColor: xstyle('char-background'),
            drawingWidth: 24,
            strokeFadeDuration: 150,
            strokeAnimationSpeed: 1.7, delayBetweenStrokes: 50,
            charDataLoader: (char, onComplete, onError) => {
                char == "" ? undefined
                    : loadAssetJSON(`_xiezh_w_${char}.json`).then(onComplete).catch(onError)
            },
            onLoadCharDataError: (e) => xlog("Writer char data load failed: " + e),
            showCharacter: false,
            showOutline: isOutlineVisible,
        })
        const setOutline = (v) => {
            (isOutlineVisible = v) ? writer.showOutline() : writer.hideOutline()
        }
        const setupHanzi = () => {
            writer.setCharacter(hanzi.sym);
            const pycolor = xstyle('py-color' + hanzi.pyTone);
            writer.updateColor('strokeColor', pycolor);
            writer.updateColor('drawingColor', pycolor);
            writer.updateColor('highlightCompleteColor', fadeto(pycolor, xstyle('stroke-color'), 0.3));
        }
        const handleMistake = (strokeData) => {
            xlog("mistake: " + !isOutlineVisible + strokeData.mistakesOnStroke)
            if (!isOutlineVisible) return;
            if (strokeData.mistakesOnStroke < 0) return; // TODO: configure

            writer.animateStroke(strokeData.strokeNum, { onComplete: resetQuiz })
        }
        const resetQuiz = () => {
            setOutline(xconfig.outline);
            writer.quiz({
                showHintAfterMisses: 2,
                markStrokeCorrectAfterMisses: 3,
                leniency: 1.3,
                onComplete: () => { onComplete?.() },
                onMistake: handleMistake,
            })
            if (xconfig.outlineTime) {
                setTimeout(() => setOutline(false), xconfig.outlineTime)
            }
        };

        setupClickerBtn('toggle-outline', () => setOutline(!isOutlineVisible));
        setupClickerBtn('run-animation', () => writer.animateCharacter());

        return {
            reset: (hanzi_, onComplete_) => {
                xlog("writer reset: " + hanzi_);
                hanzi = hanzi_;
                onComplete = onComplete_;
                writer.hideCharacter(); // prevent blinking
                setupHanzi();
                xconfig.visible ? writer.showCharacter() : resetQuiz();
            },
            forceCompletion: () => {
                xlog("writer forceCompletion: " + hanzi);
                writer.cancelQuiz();
                writer.showCharacter();
            },
            resetQuiz: resetQuiz
        }
    })();

    /**********************************************************************/
    // char display

    var charDisplay = (() => {
        return {
            reset: (hanziArr_, completedIdx_) => {
                for (let div of document.getElementById("hanzi-lines").children) {
                    buildSpans(div, hanziArr_.map(hanzi => hanzi.sym), (span, idx) => {
                        span.style.color = completedIdx_[idx]
                            ? xstyle('py-color' + hanziArr_[idx].pyTone)
                            : xstyle('stroke-color')
                    })
                }
            }
        }
    })();

    /**********************************************************************/
    // similar characters quiz

    var similarQuiz = (() => {
        let onSuccess;

        const rsort = (arr) => arr.sort(() => Math.random() - 0.5)
        const getSymArr = async (sym) => {
            let node = (await hanziData.fetch()).hgraph.get(sym)
            if (node == undefined) {
                return ""
            }
            let similar = node.parts
                .map(n => n.usedin
                    .slice(0, 6)
                    .map(n => n.sym).filter(s => s != sym))
                .flat()
            similar.push(...node.usedin.map(n => n.sym).slice(4))
            similar = rsort(similar).slice(0, 10)
            similar.push(sym)
            return rsort(similar)
        }
        const setupDiv = (text, hanzi) => {
            let div = document.getElementById("similar-quiz")
            buildSpans(div, text, (span, idx) => {
                span.classList.add('ch')
            })
            div.addEventListener('click', (e) => {
                const el = e.target.closest('.ch');
                if (!el) { return }
                let correct = el.textContent == hanzi.sym
                el.style.textDecoration = correct ? 'underline' : 'overline'
                if (correct) {
                    el.style.color = xstyle('py-color' + hanzi.pyTone)
                    onSuccess?.()
                }
            });
        }
        return {
            reset: (hanzi_, onSuccess_) => {
                onSuccess = onSuccess_
                getSymArr(hanzi_.sym).then(text => setupDiv(text, hanzi_))
            }
        }
    })();

    /**********************************************************************/
    // pinyin quiz

    var pinyinQuiz = (() => {
        let hanzi = undefined;
        let onSuccess = undefined;

        const forEachBtn = (cb) => {
            document.querySelectorAll('.tone-btn').forEach((btn, index) => cb(btn, index + 1))
        }

        const flushButtonColors = () => {
            forEachBtn((btn, pyTone) => {
                // btn.style.backgroundColor = '';
                btn.style.backgroundColor = xstyle('py-color' + pyTone)
                btn.onmouseover = btn.onmouseout = null
            });
        };

        forEachBtn((btn, pyTone) => {
            btn.addEventListener('click', errCheck(() => {
                flushButtonColors();
                if (pyTone === hanzi.pyTone) {
                    onSuccess?.()
                }
            }));
        });

        return {
            reset: (hanzi_, onSuccess_) => {
                xlog("pinyinQuiz reset: " + hanzi_)
                hanzi = hanzi_
                onSuccess = onSuccess_
                flushButtonColors();
            }
        }
    })();

    /**********************************************************************/
    // main

    var xnote = (() => {
        let hanziArr = undefined;
        let completedIdx = undefined;
        let charIdx = 0;

        const nextChar = () => {
            if (hanziArr.length > 1) {
                charIdx = (charIdx + 1) % hanziArr.length;
                update();
            }
        }

        const onCharCompleted = () => {
            const hanzi = hanziArr[charIdx];
            completedIdx[charIdx] = true;
            charDisplay.reset(hanziArr, completedIdx);
            hanzi.audio.play();
        }

        const updateCharInfo = (data, hanzi) => {
            let elem = document.getElementById("char-info");
            let node = data.hgraph.get(hanzi.sym)
            if (node == undefined) {
                elem.innerText = "no data"
                return
            }
            let fidx = data.freqlist.indexOf(hanzi.sym)
            let parts = node.parts.map(n => n.sym).join("")
            let usedin = node.usedin.slice(0, 7)
                .map(n => n.sym).filter(s => {
                    let idx = data.freqlist.indexOf(s);
                    return idx != -1 && idx < 3000 // TODO: configure
                })
                .join("")
            elem.innerText = "" + (fidx == -1 ? "" : fidx)
                + " " + hanzi.sym + " / " + parts + " / " + usedin;
        }

        const update = () => {
            const hanzi = hanziArr[charIdx];
            xlog("xnote updateChar: " + charIdx + hanzi);
            hanziWriter.reset(hanzi, () => {
                onCharCompleted();
            });
            if (completedIdx[charIdx]) {
                hanziWriter.forceCompletion()
            }
            pinyinQuiz.reset(hanzi, () => {
                onCharCompleted();
                hanziWriter.forceCompletion();
                // setTimeout(() => nextChar(), 700) // TODO: configure
            });
            similarQuiz.reset(hanzi, () => {
                onCharCompleted();
            });
            hanziData.fetch().then(data => updateCharInfo(data, hanzi))
        }

        setupClickerBtn('next-character', () => nextChar());

        setupClickerBtn('restart-quiz', () => {
            const hanzi = hanziArr[charIdx];
            hanziWriter.resetQuiz()
            similarQuiz.reset(hanzi, () => {
                onCharCompleted();
            });
        })

        setupClickerBtn('play-full-audio', () => {
            let idx = 0;
            const playNext = () => {
                if (idx < hanziArr.length) {
                    const audio = hanziArr[idx++].audio;
                    audio.play();
                    audio.onended = () => {
                        audio.onended = undefined;
                        playNext();
                    }
                }
            }
            playNext();
        });

        setupClickerBtn('pleco-lookup', () => {
            const text = hanziArr.map(h => h.sym).join("")
            window.open(`plecoapi://x-callback-url/s?q=${text}`, '_blank');
        });

        setupClickerBtn('tatoeba-lookup', () => {
            const text = hanziArr.map(h => h.sym).join("")
            const url =
                `https://tatoeba.org/en/sentences/search?from=cmn&has_audio=&list=&native=&original=
                &orphans=no&query=${encodeURIComponent(text)}&sort=relevance&sort_reverse=&tags=
                &to=eng&trans_filter=limit&trans_has_audio=&trans_link=&trans_orphan=
                &trans_to=eng&trans_unapproved=&trans_user=&unapproved=no&user=&word_count_max=&word_count_min=5`
                    .replace(/\s+/g, '');
            window.open(url, "blank_");
        });

        setupClickerBtn('change-mode', () => {
            xnoteConfigs.next()
            update()
        });

        return {
            reset: (hText, hPinyin) => {
                xlog("xnote init: " + hText + " " + hPinyin)
                hanziArr = HanziChar.buildChars(hText, hPinyin)
                completedIdx = {}
                document.getElementById('next-character').style.visibility =
                    hanziArr.length > 1 ? 'initial' : 'hidden';
                update();
            }
        }
    })();

    (async () => {
        hanziData.fetch()
        errCheck(() => xnote.reset("{{text-sc}}", "{{pinyin}}"))()
    })()

</script>

<style>
    .flat-btn {
        border: none;
        box-shadow: none;
        padding: 10px 15px;
        border-radius: 5px;
        background-color: var(--btn-background);
        color: var(--btn-color);
        font-size: 20px;
        cursor: pointer;
        transition: background-color 0.1s;
    }

    .flat-btn:hover {
        border: none;
        box-shadow: none;
        background-color: var(--btn-hover);
    }

    .tone-btn {
        width: 40px;
        height: 40px;
        font-size: 16px;
        border-radius: 5px;
    }

    .grid-color {
        margin: 6px;
        background-color: var(--char-background);
        padding: 2px;
        -webkit-box-shadow: 0px 0px 10px -5px rgba(0, 0, 0, 0.5);
        -moz-box-shadow: 0px 0px 10px -5px rgba(0, 0, 0, 0.5);
        box-shadow: 0px 0px 10px -5px rgba(0, 0, 0, 0.5);
    }
</style>